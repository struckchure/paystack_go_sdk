/*
Paystack

The OpenAPI specification of the Paystack API that merchants and developers can harness to build financial solutions in Africa.

API version: 1.0.0
Contact: techsupport@paystack.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paystack

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// TransactionAPIService TransactionAPI service
type TransactionAPIService service

type ApiTransactionChargeAuthorizationRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	email *string
	amount *int32
	authorizationCode *string
	reference *string
	currency *string
	metadata *string
	splitCode *string
	subaccount *string
	transactionCharge *string
	bearer *string
	queue *bool
}

// Customer&#39;s email address
func (r ApiTransactionChargeAuthorizationRequest) Email(email string) ApiTransactionChargeAuthorizationRequest {
	r.email = &email
	return r
}

// Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR
func (r ApiTransactionChargeAuthorizationRequest) Amount(amount int32) ApiTransactionChargeAuthorizationRequest {
	r.amount = &amount
	return r
}

// Valid authorization code to charge
func (r ApiTransactionChargeAuthorizationRequest) AuthorizationCode(authorizationCode string) ApiTransactionChargeAuthorizationRequest {
	r.authorizationCode = &authorizationCode
	return r
}

// Unique transaction reference. Only -, ., &#x3D; and alphanumeric characters allowed.
func (r ApiTransactionChargeAuthorizationRequest) Reference(reference string) ApiTransactionChargeAuthorizationRequest {
	r.reference = &reference
	return r
}

// The transaction currency
func (r ApiTransactionChargeAuthorizationRequest) Currency(currency string) ApiTransactionChargeAuthorizationRequest {
	r.currency = &currency
	return r
}

// Stringified JSON object of custom data
func (r ApiTransactionChargeAuthorizationRequest) Metadata(metadata string) ApiTransactionChargeAuthorizationRequest {
	r.metadata = &metadata
	return r
}

// The split code of the transaction split
func (r ApiTransactionChargeAuthorizationRequest) SplitCode(splitCode string) ApiTransactionChargeAuthorizationRequest {
	r.splitCode = &splitCode
	return r
}

// The code for the subaccount that owns the payment
func (r ApiTransactionChargeAuthorizationRequest) Subaccount(subaccount string) ApiTransactionChargeAuthorizationRequest {
	r.subaccount = &subaccount
	return r
}

// A flat fee to charge the subaccount for a transaction.  This overrides the split percentage set when the subaccount was created
func (r ApiTransactionChargeAuthorizationRequest) TransactionCharge(transactionCharge string) ApiTransactionChargeAuthorizationRequest {
	r.transactionCharge = &transactionCharge
	return r
}

// The beare of the transaction charge
func (r ApiTransactionChargeAuthorizationRequest) Bearer(bearer string) ApiTransactionChargeAuthorizationRequest {
	r.bearer = &bearer
	return r
}

// If you are making a scheduled charge call, it is a good idea to queue them so the processing system does not get overloaded causing transaction processing errors.
func (r ApiTransactionChargeAuthorizationRequest) Queue(queue bool) ApiTransactionChargeAuthorizationRequest {
	r.queue = &queue
	return r
}

func (r ApiTransactionChargeAuthorizationRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionChargeAuthorizationExecute(r)
}

/*
TransactionChargeAuthorization Charge Authorization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionChargeAuthorizationRequest
*/
func (a *TransactionAPIService) TransactionChargeAuthorization(ctx context.Context) ApiTransactionChargeAuthorizationRequest {
	return ApiTransactionChargeAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionChargeAuthorizationExecute(r ApiTransactionChargeAuthorizationRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionChargeAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/charge_authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.authorizationCode == nil {
		return localVarReturnValue, nil, reportError("authorizationCode is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "authorization_code", r.authorizationCode, "", "")
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reference", r.reference, "", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	}
	if r.metadata != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "metadata", r.metadata, "", "")
	}
	if r.splitCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "split_code", r.splitCode, "", "")
	}
	if r.subaccount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subaccount", r.subaccount, "", "")
	}
	if r.transactionCharge != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transaction_charge", r.transactionCharge, "", "")
	}
	if r.bearer != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "bearer", r.bearer, "", "")
	}
	if r.queue != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "queue", r.queue, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionCheckAuthorizationRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	email *string
	amount *int32
	authorizationCode *string
	currency *string
}

// Customer&#39;s email address
func (r ApiTransactionCheckAuthorizationRequest) Email(email string) ApiTransactionCheckAuthorizationRequest {
	r.email = &email
	return r
}

// Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR
func (r ApiTransactionCheckAuthorizationRequest) Amount(amount int32) ApiTransactionCheckAuthorizationRequest {
	r.amount = &amount
	return r
}

// Valid authorization code to charge
func (r ApiTransactionCheckAuthorizationRequest) AuthorizationCode(authorizationCode string) ApiTransactionCheckAuthorizationRequest {
	r.authorizationCode = &authorizationCode
	return r
}

// The transaction currency
func (r ApiTransactionCheckAuthorizationRequest) Currency(currency string) ApiTransactionCheckAuthorizationRequest {
	r.currency = &currency
	return r
}

func (r ApiTransactionCheckAuthorizationRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionCheckAuthorizationExecute(r)
}

/*
TransactionCheckAuthorization Check Authorization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionCheckAuthorizationRequest
*/
func (a *TransactionAPIService) TransactionCheckAuthorization(ctx context.Context) ApiTransactionCheckAuthorizationRequest {
	return ApiTransactionCheckAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionCheckAuthorizationExecute(r ApiTransactionCheckAuthorizationRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionCheckAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/check_authorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.authorizationCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "authorization_code", r.authorizationCode, "", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionDownloadRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	perPage *int32
	page *int32
	from *time.Time
	to *time.Time
}

// Number of records to fetch per page
func (r ApiTransactionDownloadRequest) PerPage(perPage int32) ApiTransactionDownloadRequest {
	r.perPage = &perPage
	return r
}

// The section to retrieve
func (r ApiTransactionDownloadRequest) Page(page int32) ApiTransactionDownloadRequest {
	r.page = &page
	return r
}

// The start date
func (r ApiTransactionDownloadRequest) From(from time.Time) ApiTransactionDownloadRequest {
	r.from = &from
	return r
}

// The end date
func (r ApiTransactionDownloadRequest) To(to time.Time) ApiTransactionDownloadRequest {
	r.to = &to
	return r
}

func (r ApiTransactionDownloadRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionDownloadExecute(r)
}

/*
TransactionDownload Export Transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionDownloadRequest
*/
func (a *TransactionAPIService) TransactionDownload(ctx context.Context) ApiTransactionDownloadRequest {
	return ApiTransactionDownloadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionDownloadExecute(r ApiTransactionDownloadRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionEventRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	id string
}

func (r ApiTransactionEventRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionEventExecute(r)
}

/*
TransactionEvent Get Transaction Event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiTransactionEventRequest
*/
func (a *TransactionAPIService) TransactionEvent(ctx context.Context, id string) ApiTransactionEventRequest {
	return ApiTransactionEventRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionEventExecute(r ApiTransactionEventRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/{id}/event"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionFetchRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	id string
}

func (r ApiTransactionFetchRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionFetchExecute(r)
}

/*
TransactionFetch Fetch Transaction

Fetch a transaction to get its details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the transaction to fetch
 @return ApiTransactionFetchRequest
*/
func (a *TransactionAPIService) TransactionFetch(ctx context.Context, id string) ApiTransactionFetchRequest {
	return ApiTransactionFetchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionFetchExecute(r ApiTransactionFetchRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionFetch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionInitializeRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	email *string
	amount *int32
	currency *string
	reference *string
	callbackUrl *string
	plan *string
	invoiceLimit *int32
	metadata *string
	channels *[]string
	splitCode *string
	subaccount *string
	transactionCharge *string
	bearer *string
}

// Customer&#39;s email address
func (r ApiTransactionInitializeRequest) Email(email string) ApiTransactionInitializeRequest {
	r.email = &email
	return r
}

// Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR
func (r ApiTransactionInitializeRequest) Amount(amount int32) ApiTransactionInitializeRequest {
	r.amount = &amount
	return r
}

// The transaction currency
func (r ApiTransactionInitializeRequest) Currency(currency string) ApiTransactionInitializeRequest {
	r.currency = &currency
	return r
}

// Unique transaction reference. Only -, ., &#x3D; and alphanumeric characters allowed.
func (r ApiTransactionInitializeRequest) Reference(reference string) ApiTransactionInitializeRequest {
	r.reference = &reference
	return r
}

// Fully qualified url, e.g. https://example.com/ . Use this to override the callback url provided on the dashboard for this transaction
func (r ApiTransactionInitializeRequest) CallbackUrl(callbackUrl string) ApiTransactionInitializeRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// If transaction is to create a subscription to a predefined plan, provide plan code here.  This would invalidate the value provided in amount
func (r ApiTransactionInitializeRequest) Plan(plan string) ApiTransactionInitializeRequest {
	r.plan = &plan
	return r
}

// Number of times to charge customer during subscription to plan
func (r ApiTransactionInitializeRequest) InvoiceLimit(invoiceLimit int32) ApiTransactionInitializeRequest {
	r.invoiceLimit = &invoiceLimit
	return r
}

// Stringified JSON object of custom data
func (r ApiTransactionInitializeRequest) Metadata(metadata string) ApiTransactionInitializeRequest {
	r.metadata = &metadata
	return r
}

// An array of payment channels to control what channels you want to make available to the user to make a payment with
func (r ApiTransactionInitializeRequest) Channels(channels []string) ApiTransactionInitializeRequest {
	r.channels = &channels
	return r
}

// The split code of the transaction split
func (r ApiTransactionInitializeRequest) SplitCode(splitCode string) ApiTransactionInitializeRequest {
	r.splitCode = &splitCode
	return r
}

// The code for the subaccount that owns the payment
func (r ApiTransactionInitializeRequest) Subaccount(subaccount string) ApiTransactionInitializeRequest {
	r.subaccount = &subaccount
	return r
}

// A flat fee to charge the subaccount for a transaction.  This overrides the split percentage set when the subaccount was created
func (r ApiTransactionInitializeRequest) TransactionCharge(transactionCharge string) ApiTransactionInitializeRequest {
	r.transactionCharge = &transactionCharge
	return r
}

// The beare of the transaction charge
func (r ApiTransactionInitializeRequest) Bearer(bearer string) ApiTransactionInitializeRequest {
	r.bearer = &bearer
	return r
}

func (r ApiTransactionInitializeRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionInitializeExecute(r)
}

/*
TransactionInitialize Initialize Transaction

Create a new transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionInitializeRequest
*/
func (a *TransactionAPIService) TransactionInitialize(ctx context.Context) ApiTransactionInitializeRequest {
	return ApiTransactionInitializeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionInitializeExecute(r ApiTransactionInitializeRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionInitialize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/initialize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	}
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reference", r.reference, "", "")
	}
	if r.callbackUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callback_url", r.callbackUrl, "", "")
	}
	if r.plan != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "plan", r.plan, "", "")
	}
	if r.invoiceLimit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "invoice_limit", r.invoiceLimit, "", "")
	}
	if r.metadata != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "metadata", r.metadata, "", "")
	}
	if r.channels != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "channels", r.channels, "", "csv")
	}
	if r.splitCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "split_code", r.splitCode, "", "")
	}
	if r.subaccount != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "subaccount", r.subaccount, "", "")
	}
	if r.transactionCharge != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transaction_charge", r.transactionCharge, "", "")
	}
	if r.bearer != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "bearer", r.bearer, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	perPage *int32
	page *int32
	from *time.Time
	to *time.Time
}

// Number of records to fetch per page
func (r ApiTransactionListRequest) PerPage(perPage int32) ApiTransactionListRequest {
	r.perPage = &perPage
	return r
}

// The section to retrieve
func (r ApiTransactionListRequest) Page(page int32) ApiTransactionListRequest {
	r.page = &page
	return r
}

// The start date
func (r ApiTransactionListRequest) From(from time.Time) ApiTransactionListRequest {
	r.from = &from
	return r
}

// The end date
func (r ApiTransactionListRequest) To(to time.Time) ApiTransactionListRequest {
	r.to = &to
	return r
}

func (r ApiTransactionListRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionListExecute(r)
}

/*
TransactionList List Transactions

List transactions that has occurred on your integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionListRequest
*/
func (a *TransactionAPIService) TransactionList(ctx context.Context) ApiTransactionListRequest {
	return ApiTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionListExecute(r ApiTransactionListRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionPartialDebitRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	email *string
	amount *int32
	authorizationCode *string
	currency *string
	reference *string
	atLeast *string
}

// Customer&#39;s email address
func (r ApiTransactionPartialDebitRequest) Email(email string) ApiTransactionPartialDebitRequest {
	r.email = &email
	return r
}

// Amount should be in kobo if currency is NGN, pesewas, if currency is GHS, and cents, if currency is ZAR
func (r ApiTransactionPartialDebitRequest) Amount(amount int32) ApiTransactionPartialDebitRequest {
	r.amount = &amount
	return r
}

// Valid authorization code to charge
func (r ApiTransactionPartialDebitRequest) AuthorizationCode(authorizationCode string) ApiTransactionPartialDebitRequest {
	r.authorizationCode = &authorizationCode
	return r
}

// The transaction currency
func (r ApiTransactionPartialDebitRequest) Currency(currency string) ApiTransactionPartialDebitRequest {
	r.currency = &currency
	return r
}

// Unique transaction reference. Only -, ., &#x3D; and alphanumeric characters allowed.
func (r ApiTransactionPartialDebitRequest) Reference(reference string) ApiTransactionPartialDebitRequest {
	r.reference = &reference
	return r
}

// Minimum amount to charge
func (r ApiTransactionPartialDebitRequest) AtLeast(atLeast string) ApiTransactionPartialDebitRequest {
	r.atLeast = &atLeast
	return r
}

func (r ApiTransactionPartialDebitRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionPartialDebitExecute(r)
}

/*
TransactionPartialDebit Partial Debit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionPartialDebitRequest
*/
func (a *TransactionAPIService) TransactionPartialDebit(ctx context.Context) ApiTransactionPartialDebitRequest {
	return ApiTransactionPartialDebitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionPartialDebitExecute(r ApiTransactionPartialDebitRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionPartialDebit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/partial_debit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.authorizationCode == nil {
		return localVarReturnValue, nil, reportError("authorizationCode is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "amount", r.amount, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "authorization_code", r.authorizationCode, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "currency", r.currency, "", "")
	if r.reference != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reference", r.reference, "", "")
	}
	if r.atLeast != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "at_least", r.atLeast, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionSessionRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	id string
}

func (r ApiTransactionSessionRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionSessionExecute(r)
}

/*
TransactionSession Get Transaction Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiTransactionSessionRequest
*/
func (a *TransactionAPIService) TransactionSession(ctx context.Context, id string) ApiTransactionSessionRequest {
	return ApiTransactionSessionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionSessionExecute(r ApiTransactionSessionRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/{id}/session"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionTimelineRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	idOrReference string
}

func (r ApiTransactionTimelineRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionTimelineExecute(r)
}

/*
TransactionTimeline Fetch Transaction Timeline

Get the details about the lifecycle of a transaction from initiation to completion

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrReference
 @return ApiTransactionTimelineRequest
*/
func (a *TransactionAPIService) TransactionTimeline(ctx context.Context, idOrReference string) ApiTransactionTimelineRequest {
	return ApiTransactionTimelineRequest{
		ApiService: a,
		ctx: ctx,
		idOrReference: idOrReference,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionTimelineExecute(r ApiTransactionTimelineRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionTimeline")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/timeline/{id_or_reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"id_or_reference"+"}", url.PathEscape(parameterValueToString(r.idOrReference, "idOrReference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionTotalsRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	perPage *int32
	page *int32
	from *time.Time
	to *time.Time
}

// Number of records to fetch per page
func (r ApiTransactionTotalsRequest) PerPage(perPage int32) ApiTransactionTotalsRequest {
	r.perPage = &perPage
	return r
}

// The section to retrieve
func (r ApiTransactionTotalsRequest) Page(page int32) ApiTransactionTotalsRequest {
	r.page = &page
	return r
}

// The start date
func (r ApiTransactionTotalsRequest) From(from time.Time) ApiTransactionTotalsRequest {
	r.from = &from
	return r
}

// The end date
func (r ApiTransactionTotalsRequest) To(to time.Time) ApiTransactionTotalsRequest {
	r.to = &to
	return r
}

func (r ApiTransactionTotalsRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionTotalsExecute(r)
}

/*
TransactionTotals Transaction Totals

Get the total amount of all transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionTotalsRequest
*/
func (a *TransactionAPIService) TransactionTotals(ctx context.Context) ApiTransactionTotalsRequest {
	return ApiTransactionTotalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionTotalsExecute(r ApiTransactionTotalsRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/totals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "form", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionVerifyRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	reference string
}

func (r ApiTransactionVerifyRequest) Execute() (*Response, *http.Response, error) {
	return r.ApiService.TransactionVerifyExecute(r)
}

/*
TransactionVerify Verify Transaction

Verify a previously initiated transaction using it's reference

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param reference The transaction reference to verify
 @return ApiTransactionVerifyRequest
*/
func (a *TransactionAPIService) TransactionVerify(ctx context.Context, reference string) ApiTransactionVerifyRequest {
	return ApiTransactionVerifyRequest{
		ApiService: a,
		ctx: ctx,
		reference: reference,
	}
}

// Execute executes the request
//  @return Response
func (a *TransactionAPIService) TransactionVerifyExecute(r ApiTransactionVerifyRequest) (*Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.TransactionVerify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transaction/verify/{reference}"
	localVarPath = strings.Replace(localVarPath, "{"+"reference"+"}", url.PathEscape(parameterValueToString(r.reference, "reference")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
